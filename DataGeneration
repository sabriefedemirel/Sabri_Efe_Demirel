# ==========================================
# Adana Urban LV (PyPSA)
# pip install pypsa pvlib pandas numpy matplotlib openpyxl
# ==========================================
import numpy as np, pandas as pd, matplotlib.pyplot as plt, matplotlib.dates as mdates, pypsa


cfg = dict(
    TZ="Europe/Istanbul", START="2025-07-01 00:00", END="2025-09-30 23:45", FREQ="5min",
    N_HOUSES=100, N_FEEDERS=4, BUSES_PER_FEEDER=5, PEN=[.20,.40,.60,.80],
    OV=1.05, UV=0.95, V_LL_KV=0.5, S_BASE_MVA=0.9,
    TR_R=0.04, TR_X=0.08, R_OHM_KM=0.40, X_OHM_KM=0.08, LEN_MIN=0.03, LEN_MAX=0.15,
    PF=0.95, SLACK_VSET=1.01, GAMMA=-0.004,
    SAVE=True, CSV="adanurban_lv_dataset.csv", XLSX="adanurban_lv_dataset.xlsx",
    REP_DAY="2025-07-15", XAXIS="full15"  # "readable" da olur
)

# --------- 1) TIME ----------
SNAP_TZ = pd.date_range(cfg["START"], cfg["END"], freq=cfg["FREQ"], tz=cfg["TZ"])
SNAP = SNAP_TZ.tz_localize(None)
DT = pd.Timedelta(cfg["FREQ"])
DT_H = DT.total_seconds()/3600
T = len(SNAP)
STEPS_PER_DAY = int(round(24/DT_H))
N_DAYS = int(np.ceil(T/STEPS_PER_DAY))
t = np.arange(T)
day_idx = np.minimum(t//STEPS_PER_DAY, N_DAYS-1)
hour = (t % STEPS_PER_DAY) * DT_H

# --------- 2) TOPOLOGY + MAPPING ----------
N_BUSES = cfg["N_FEEDERS"] * cfg["BUSES_PER_FEEDER"]
lv = [f"LV{i+1}" for i in range(N_BUSES)]
allb = ["LV0"] + lv
HOUSES_PER_BUS = cfg["N_HOUSES"] // N_BUSES
house_to_bus = np.repeat(np.arange(N_BUSES), HOUSES_PER_BUS)

Z_BASE = (cfg["V_LL_KV"]**2) / cfg["S_BASE_MVA"]
rng_top = np.random.default_rng(123)
feeders = [list(range(f*cfg["BUSES_PER_FEEDER"], (f+1)*cfg["BUSES_PER_FEEDER"])) for f in range(cfg["N_FEEDERS"])]
seg_len = rng_top.uniform(cfg["LEN_MIN"], cfg["LEN_MAX"], size=(cfg["N_FEEDERS"], cfg["BUSES_PER_FEEDER"]))
R_pu = (cfg["R_OHM_KM"]*seg_len)/Z_BASE
X_pu = (cfg["X_OHM_KM"]*seg_len)/Z_BASE

TANPHI = np.tan(np.arccos(cfg["PF"]))

# --------- 3) PROFILES (LOAD + PV + METEO) ----------
def build_load():
    rng = np.random.default_rng(0)
    base = (np.sin(((t*DT_H) - 18)*np.pi/12)+1)/2
    base = (0.25 + 0.75*base)/base.max()
    dow = pd.Series(SNAP).dt.dayofweek.values
    weekend = np.where(dow>=5, 1.08, 1.00)
    daily = np.clip(rng.normal(1.0,0.12,size=N_DAYS), 0.75, 1.35)
    peak_kw = rng.uniform(1.5,5.0,size=cfg["N_HOUSES"])
    noise = rng.normal(1.0,0.06,size=(T,cfg["N_HOUSES"]))
    scale = weekend * daily[day_idx]
    p_kw = np.clip((base*scale)[:,None] * peak_kw[None,:] * noise, 0, None)
    return pd.DataFrame(p_kw/1000, index=SNAP, columns=[f"house_{i}" for i in range(cfg["N_HOUSES"])])

def build_meteo():
    rng = np.random.default_rng(2025)
    shift = np.clip(rng.normal(0,1.2,size=N_DAYS), -3, 3)
    temp_air = 30 + 6*np.sin((hour-14)*np.pi/12) + shift[day_idx] + rng.normal(0,0.5,size=T)
    temp_air = pd.Series(np.clip(temp_air,20,45), index=SNAP_TZ)
    wind = 2 + 0.7*np.sin((hour-12)*np.pi/12) + rng.normal(0,0.3,size=T)
    wind = pd.Series(np.clip(wind,0.2,6), index=SNAP_TZ)

    if PVLIB_OK:
        loc = pvlib.location.Location(36.99, 35.33, tz=cfg["TZ"])
        cs = loc.get_clearsky(SNAP_TZ, model="ineichen")
        sol = loc.get_solarposition(SNAP_TZ)
        poa = pvlib.irradiance.get_total_irradiance(
            surface_tilt=25, surface_azimuth=180,
            dni=cs["dni"], ghi=cs["ghi"], dhi=cs["dhi"],
            solar_zenith=sol["zenith"], solar_azimuth=sol["azimuth"]
        )["poa_global"].where(sol["apparent_elevation"]>0, 0.0).astype(float)
        tcell = pvlib.temperature.faiman(poa_global=poa, temp_air=temp_air, wind_speed=wind)
    else:
        sun = np.maximum(0, np.sin((hour-6)*np.pi/12))
        poa = pd.Series(950*sun, index=SNAP_TZ)
        tcell = temp_air + 0.02*poa - 1.5*(wind-2)
    met = pd.DataFrame({"poa_wm2":poa.tz_localize(None).values, "temp_air_c":temp_air.tz_localize(None).values}, index=SNAP)
    return poa.to_numpy(), tcell.to_numpy(), met

def build_pv():
    rng = np.random.default_rng(42)
    rated_kw = rng.uniform(3.0,7.0,size=cfg["N_HOUSES"])
    poa_arr, tcell_arr, met = build_meteo()
    daily_scale = np.clip(np.random.default_rng(7).normal(1.0,0.20,size=N_DAYS), 0.60, 1.25)
    cloud = rng.normal(1.0,0.10,size=(T,cfg["N_HOUSES"]))
    irr = np.clip(poa_arr[:,None] * cloud * daily_scale[day_idx][:,None], 0, None)

    PV = np.zeros((T,cfg["N_HOUSES"]))
    if PVLIB_OK:
        for i in range(cfg["N_HOUSES"]):
            PV[:,i] = np.clip(np.asarray(pvlib.pvsystem.pvwatts_dc(
                g_poa_effective=irr[:,i], temp_cell=tcell_arr,
                pdc0=rated_kw[i]*1000, gamma_pdc=cfg["GAMMA"]
            ),dtype=float),0,None)/1e6
    else:
        PV = np.clip((rated_kw[None,:]*1000)*(irr/1000)*(1+cfg["GAMMA"]*(tcell_arr[:,None]-25)),0,None)/1e6

    PV_H = pd.DataFrame(PV, index=SNAP, columns=[f"house_{i}" for i in range(cfg["N_HOUSES"])])
    return PV_H, met, rated_kw

print("Building profiles ...")
LOAD_H = build_load()
PV_H, METEO, PV_RATED_KW = build_pv()

# --------- 4) BUS AGGREGATION ----------
P_LOAD_BUS = pd.DataFrame(0.0, index=SNAP, columns=lv)
np.add.at(P_LOAD_BUS.values, (np.arange(T)[:,None], house_to_bus[None,:]), LOAD_H.values)
Q_LOAD_BUS = P_LOAD_BUS * TANPHI

pv_order = np.random.default_rng(999).permutation(np.arange(cfg["N_HOUSES"]))

def pv_bus(p):
    n = int(round(p*cfg["N_HOUSES"]))
    chosen = pv_order[:n]
    P = pd.DataFrame(0.0, index=SNAP, columns=lv)
    np.add.at(P.values, (np.arange(T)[:,None], house_to_bus[chosen][None,:]), PV_H.iloc[:,chosen].values)
    return P, chosen

# --------- 5) PYPSA: build + run ----------
def build_net():
    net = pypsa.Network(); net.set_snapshots(SNAP)
    net.add("Bus","LV0", v_nom=cfg["V_LL_KV"])
    for b in lv: net.add("Bus", b, v_nom=cfg["V_LL_KV"])

    net.add("Generator","Slack", bus="LV0", control="Slack", p_nom=10.0)
    net.generators.loc["Slack","v_mag_pu_set"] = cfg["SLACK_VSET"]

    for f in range(cfg["N_FEEDERS"]):
        fb = feeders[f][0]
        net.add("Line", f"TX_F{f+1}", bus0="LV0", bus1=f"LV{fb+1}", r=cfg["TR_R"], x=cfg["TR_X"], s_nom=10.0)

    for f in range(cfg["N_FEEDERS"]):
        bs = feeders[f]
        for i, b in enumerate(bs[:-1]):
            net.add("Line", f"F{f+1}_SEG{i+1}", bus0=f"LV{b+1}", bus1=f"LV{bs[i+1]+1}",
                    r=float(R_pu[f,i]), x=float(X_pu[f,i]), s_nom=5.0)

    for b in lv:
        net.add("Load", f"Load_{b}", bus=b, p_set=0.0, q_set=0.0)
        net.add("Generator", f"PV_{b}", bus=b, control="PQ", p_nom=10.0)
        net.loads_t.p_set[f"Load_{b}"] = P_LOAD_BUS[b].values
        net.loads_t.q_set[f"Load_{b}"] = Q_LOAD_BUS[b].values
        net.generators_t.q_set[f"PV_{b}"] = np.zeros(T)

    net.generators_t.p_set["Slack"] = np.zeros(T)
    return net

def run(p):
    print(f"Running PF for PV penetration = {int(p*100)}% ...")
    net = build_net()
    P_PV_BUS, chosen = pv_bus(p)
    for b in lv:
        net.generators_t.p_set[f"PV_{b}"] = P_PV_BUS[b].values

    net.pf()
    V = net.buses_t.v_mag_pu[allb].copy()
    Vlv = V[lv]
    vmin, vmax = Vlv.min(axis=1), Vlv.max(axis=1)
    ov_any = (vmax > cfg["OV"]).astype(int)
    uv_any = (vmin < cfg["UV"]).astype(int)
    ov_daily = pd.Series(ov_any, index=SNAP).resample("D").sum()*DT_H
    uv_daily = pd.Series(uv_any, index=SNAP).resample("D").sum()*DT_H
    return dict(V0=V["LV0"], vmin=vmin, vmax=vmax, ov_daily=ov_daily, uv_daily=uv_daily, chosen=chosen)

results = {p: run(p) for p in cfg["PEN"]}
print("All scenarios completed.")

# --------- 6) DATASET EXPORT ----------
if cfg["SAVE"]:
    total_load = P_LOAD_BUS.sum(axis=1)
    base = pd.DataFrame({
        "timestamp": SNAP,
        "total_load_mw": total_load.values,
        "poa_wm2": METEO["poa_wm2"].values,
        "temp_air_c": METEO["temp_air_c"].values
    })
    out = []
    for p in cfg["PEN"]:
        P_PV_BUS, _ = pv_bus(p)
        total_pv = P_PV_BUS.sum(axis=1)
        netinj = total_pv - total_load
        V0, vmin, vmax = results[p]["V0"], results[p]["vmin"], results[p]["vmax"]

        dfp = base.copy()
        dfp["pv_penetration"] = p
        dfp["total_pv_mw"] = total_pv.values
        dfp["net_injection_mw"] = netinj.values
        dfp["lv0_v_pu"] = V0.values
        dfp["vmin_lv_pu"] = vmin.values
        dfp["vmax_lv_pu"] = vmax.values
        dfp["over_voltage"] = (vmax.values > cfg["OV"]).astype(int)
        dfp["under_voltage"] = (vmin.values < cfg["UV"]).astype(int)
        dfp = dfp[["timestamp","pv_penetration","total_load_mw","total_pv_mw","net_injection_mw",
                   "lv0_v_pu","vmin_lv_pu","vmax_lv_pu","over_voltage","under_voltage","poa_wm2","temp_air_c"]]
        out.append(dfp)

    df = pd.concat(out, ignore_index=True)
    df.to_csv(cfg["CSV"], index=False)
    df.to_excel(cfg["XLSX"], index=False)
    print(f"Dataset saved: {cfg['CSV']} and {cfg['XLSX']}")

# --------- 7) PLOTS ----------
def xaxis(ax):
    if cfg["XAXIS"] == "readable":
        ax.xaxis.set_major_locator(mdates.HourLocator(interval=2))
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))
        ax.xaxis.set_minor_locator(mdates.MinuteLocator(interval=15))
        ax.grid(True, which="minor", linestyle=":", alpha=0.25)
    else:
        ax.xaxis.set_major_locator(mdates.MinuteLocator(interval=15))
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))
        ax.tick_params(axis="x", labelrotation=90, labelsize=7)

day0 = pd.Timestamp(cfg["REP_DAY"]+" 00:00:00")
day1 = day0 + pd.Timedelta(days=1) - DT
mask = (SNAP>=day0) & (SNAP<=day1)

# 7.1 Envelope 2x2
fig, axs = plt.subplots(2,2, figsize=(18,8), sharex=True, sharey=True); axs = axs.ravel()
for ax, p in zip(axs, cfg["PEN"]):
    V0 = results[p]["V0"].loc[mask]
    vmin = results[p]["vmin"].loc[mask]
    vmax = results[p]["vmax"].loc[mask]
    tt = V0.index
    ax.fill_between(tt, vmin.values, vmax.values, alpha=0.25, label="Min–Max band")
    ax.plot(tt, V0.values, lw=1.8, label="LV0")
    ax.plot(tt, vmax.values, lw=1.2, label="max")
    ax.plot(tt, vmin.values, lw=1.2, label="min")
    ax.axhline(cfg["OV"], ls="--", label="OV")
    ax.axhline(cfg["UV"], ls="--", label="UV")
    ax.set_title(f"{int(p*100)}% PV (1-day zoom)")
    ax.set_ylabel("V (p.u.)"); ax.grid(True, ls=":", alpha=0.8); xaxis(ax)

fig.suptitle(f"Adana Urban LV — Bus Voltage Envelope (4 scenarios, 1-day, {cfg['FREQ']})", y=0.98)
handles, labels = axs[0].get_legend_handles_labels()
fig.legend(handles, labels, loc="upper center", bbox_to_anchor=(0.5,0.94), ncol=6, frameon=True)
fig.tight_layout(rect=[0.02,0.03,0.98,0.88])
plt.show()

# 7.2 Monthly OV/UV
for yy, mm in [(2025,7),(2025,8),(2025,9)]:
    m0 = pd.Timestamp(year=yy, month=mm, day=1)
    m1 = m0 + pd.offsets.MonthEnd(1)
    fig, (ax1, ax2) = plt.subplots(2,1, figsize=(18,7), sharex=True)
    for p in cfg["PEN"]:
        ax1.plot(results[p]["ov_daily"].loc[m0:m1].index, results[p]["ov_daily"].loc[m0:m1].values, label=f"{int(p*100)}% PV")
        ax2.plot(results[p]["uv_daily"].loc[m0:m1].index, results[p]["uv_daily"].loc[m0:m1].values, label=f"{int(p*100)}% PV")
    ax1.set_title(f"Daily Overvoltage Duration (any LV bus > {cfg['OV']} p.u.) — {m0:%B %Y}")
    ax2.set_title(f"Daily Undervoltage Duration (any LV bus < {cfg['UV']} p.u.) — {m0:%B %Y}")
    for ax in (ax1,ax2):
        ax.set_ylabel("hours/day"); ax.grid(True, ls=":", alpha=0.8); ax.legend(ncol=4, loc="upper right")
    ax2.set_xlim(m0,m1); ax2.xaxis.set_major_locator(mdates.DayLocator(interval=2))
    ax2.xaxis.set_major_formatter(mdates.DateFormatter("%d")); ax2.set_xlabel(f"Day of month ({m0:%b %Y})")
    plt.tight_layout(); plt.show()

    print(f"\n=== MONTH TOTALS: {m0:%B %Y} ===")
    for p in cfg["PEN"]:
        print(f"{int(p*100)}% PV -> OV: {results[p]['ov_daily'].loc[m0:m1].sum():.2f} h, UV: {results[p]['uv_daily'].loc[m0:m1].sum():.2f} h")

# 7.3 Single house (guaranteed PV house) 1 day
_, chosen60 = pv_bus(0.60)
h = int(chosen60[0])
plt.figure(figsize=(18,5))
plt.plot(LOAD_H[f"house_{h}"].loc[mask].index, LOAD_H[f"house_{h}"].loc[mask].values, label="House load (MW)")
plt.plot(PV_H[f"house_{h}"].loc[mask].index,   PV_H[f"house_{h}"].loc[mask].values,   label="House PV (MW)")
plt.title(f"Single House — Load vs PV (Representative Day: {cfg['REP_DAY']}, {cfg['FREQ']})")
plt.ylabel("Power (MW)"); plt.grid(True, ls=":", alpha=0.8); xaxis(plt.gca()); plt.legend(loc="upper right")
plt.tight_layout(); plt.show()

# --------- 8) TOTALS ----------
print("\n=== 3-MONTH TOTALS (Jul–Sep 2025) ===")
for m0s in ["2025-07-01","2025-08-01","2025-09-01"]:
    m0 = pd.Timestamp(m0s); m1 = m0 + pd.offsets.MonthBegin(1)
    print(f"\n--- MONTH TOTALS: {m0:%B %Y} ---")
    for p in cfg["PEN"]:
        ov = results[p]["ov_daily"].loc[m0:m1-pd.Timedelta(minutes=1)].sum()
        uv = results[p]["uv_daily"].loc[m0:m1-pd.Timedelta(minutes=1)].sum()
        print(f"{int(p*100)}% PV -> OV: {ov:.2f} h, UV: {uv:.2f} h")

print("\n--- TOTAL (Jul+Aug+Sep) ---")
for p in cfg["PEN"]:
    print(f"{int(p*100)}% PV -> OV: {results[p]['ov_daily'].sum():.2f} h, UV: {results[p]['uv_daily'].sum():.2f} h")
